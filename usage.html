<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="WindFlow Home Page">
  <meta name="author" content="Gabriele Mencagli">
  <title>WindFlow</title>
  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="css/scrolling-nav.css" rel="stylesheet">
  <link href="css/prism.css" rel="stylesheet" />
</head>

<body id="page-top">
  <script src="js/prism.js"></script>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">WindFlow</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html">Overview</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="patterns.html">Patterns</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#Usage">Usage</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="performance.html">Performance</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="https://github.com/ParaGroup/WindFlow.git">Download</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="credits.html">Credits</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <header class="bg-primary text-white">
    <div class="container text-center">
      <!--<h1>WindFlow</h1>-->
      <img src="logo/logo_white.png" alt="WindFlow" height="180">
      <p class="lead">A C++17 Data Stream Processing Parallel Library for Multicores and GPUs</p>
    </div>
  </header>

  <section id="Usage">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h1>Usage (Example)</h1>
          <p class="lead">In this part, we show a simple application in order to describe how to use of the <code>WindFlow</code>'s API. For further details on the library, developers can refers to the <code>doxygen</code> documentation available in the source code.</p>
          <p class="lead">The application that we propose here is a simple financial application reading data ticks from a financial market. Logically, the application can be modeled as a pipeline of four stages connected with each other as in the figure below:</p>
          <p style="text-align:center;"><img src="imgs/application.jpg" width="100%" align="middle"/></p>
          <p class="lead">The source produces a stream of records with a stock symbol (string), volume (integer), price (float), timestamp (long), identifier (long) attributes. The stream is received by a filter operator in charge of dropping all the inputs except the ones with symbol equal to <code>"my_company"</code>. The third operator computes the Volume Weighted Average Price (VWAP) of the last <code>1,000</code> records by producing a new result every <code>10</code> new items. Results are received by the sink operator.</p>
          <h2>Creating operators</h2>
          <p class="lead">First, we introduce the data type of the records exchanged by the operators. We develop the following class named <code>tick_t</code>:</p>
          <pre><code class="language-cpp">
// includes
#include&lt;windflow.hpp&gt;
...
// financial tick
struct tick_t
{
  std::string symbol;
  uint64_t id;
  uint64_t ts;
  float price;
  size_t volume;

  // default constructor
  tick_t(): key("undefined"), id(0), ts(0), price(0.0), volume(0) {}

  std::tuple<std::string, uint64_t, uint64_t> getControlFields() const
  {
    return std::make_tuple(key, id, ts);
  }

  void setControlFields(std::string _key, uint64_t _id, uint64_t _ts)
  {
    key = _key;
    id = _id;
    ts = _ts;
  }
};
          </code></pre>
          <p class="lead">All the data types exchanged by operators in <code>WindFlow</code> must provide two public methods:</p>
          <ul>
            <li><b>getControlFields()</b>: the method returns a <code>std::tuple</code> with three parameters. The first is the key attribute (with <code>string</code> type in the example). The library supports as key attributes any C++ type <code>T</code> for which the <code>std::hash&lt;T&gt;()</code> function is defined. The second field is the unique identifier (of type <code>uint64_t</code> starting from zero) of the item within the substream. The last field of the tuple is the timestamp (starting from zero with granularity at the microsecond) represented by a <code>uint64_t</code> value</li>
            <li><b>setControlFields()</b>: a method that allows the key attribute, the unique identifier and the timestamp to be set for the given input item</li>
          </ul>
          <p class="lead">The first step is to create the source operator. The business logic in charge of generating the ticks is provided by the user to the pattern builder through either a <b>lambda</b> expression, a plain <b>function</b>, or a <b>functor</b> object. In the code below, we define a functor class:</p>
          <pre><code class="language-cpp">
// source functor class
class Source_F {
public:
  size_t len;

  // constructor
  Source_F(size_t _len): len(_len) {}

  // generation main loop
  void operator()(Shipper&lt;tick_t&gt; &shipper)
  {
    for (size_t i=0; i&lt;len; i++) {
      tuple_t t = readTuple(...);
      shipper.push(t);
    }
  }
  ...
};
          </code></pre>
          <p class="lead">In the code, we have omitted the definition of the <code>readTuple()</code> function in charge of parsing input items from a network socket. In the example, the source generates a predefined number of items. To create the source pattern, the developer should use the builder class provided by the library. So doing, using the last C++17 features (<b>Class Template Argument Deduction</b>), all the template arguments needed to instantiate the pattern are automatically deduced by the function/functor/lambda provided to the builder constructor, thus making the life easier to the programmer in addition to provide a <code>fluent interface</code> for the patter creation. The construction of the source is shown below:</p>
          <pre><code class="language-cpp">
// main
int main(int argc, char *argv[]) {
    ...
    Source_F source_func(1000000);
    // creation of the Source pattern
    Source source = Source_Builder(source_func).withName("mysource")
                                               .withParallelism(2)
                                               .build();
}
          </code></pre>
          <p class="lead">The source is created with two replicas and with a string corresponding to its name in the application.</p>
          <p class="lead">The filter pattern is created in an analogous manner. First, a functor class is defined with the operator business logic, as shown below:</p>
          <pre><code class="language-cpp">
// filter functor
class Filter_F
{
public:
    bool operator()(tick_t &t)
    {
        if (t.symbol == "my_company")
            return true;
        else
            return false;
    }
};
          </code></pre>
          <p class="lead">All the input ticks with symbol not equal to <code>"my_company"</code> are dropped (return value is <code>false</code>). The pattern is created by leveraging its builder class and, in this example, with the same parallelism of the source:</p>
          <pre><code class="language-cpp">
Filter_F filter_func;
// creation of the Filter pattern
Filter filter = Filter_Builder(filter_func).withParallelism(2)
                                           .withName("myfilter")
                                           .build();
          </code></pre>
          <p class="lead">To compute the window aggregate, we use the <b>Windowed Farm</b> pattern. We note that in this application, all the items coming out from the filtering phase have the same symbol attribute. So, key-based parallelism is totally useless in this example. To instantiate the pattern, we define its business logic. In this example we use a function for that (lambda expressions or functor objects are still allowed here):</p>
          <pre><code class="language-cpp">
// user-defined window function
void vwap(uint_64_t wid, Iterable&lt;tick_t&gt; &win, result_t &r) {
    size_t total_volume = 0;
    float sum = 0;
    for (auto t: win) {
        sum += (t.price * t.volume);
        total_volume += t.volume;
    }
    result.vwap = sum/total_volume;
};
          </code></pre>
          <p class="lead">In this example, the function uses the non-incremental signature that computes the window when it is ready to be processed by giving the read-only access to all its item through a <code>Iterable</code> object. Other definitions of the function (e.g., incremental) are allowed (see the <code>doxygen</code> documentation). The type <code>result_t</code> is the result data type computed per window, providing the same control methods of <code>tick_t</code> (i.e. <code>getControlFields()</code> and <code>setControlFields()</code>). The pattern is created through its builder class:</p>
          <pre><code class="language-cpp">
Win_Farm win_agg = WinFarm_Builder(vwap).withCBWindow(1000, 10)
                                        .withParallelism(3)
                                        .withName("myvwap")
                                        .build();
          </code></pre>
          <p class="lead">The pattern is created with three replicas and with a count-based window semantics. Finally, the sink operator is created, first implementing its business logic:</p>
          <pre><code class="language-cpp">
// sink functor
class Sink_F
{
    size_t received;
public:
    // constructor
    Sink_Functor(): received(0) {}

    // operator()
    void operator()(std::optional&lt;result_t&gt; &out)
    {
        if (out) {
            received++;
            cout << "Window " << *out.id << " vwap " << *out.vwap << endl;
        }
        else
            cout << "End stream" << endl;
    }
};
          </code></pre>
          <p class="lead">The function is called by the run-time system of the library each time a new item is received. The item is encapsulated in a <code>std::optional</code>. This allows checking the end of the stream (in that case the optional returns <code>false</code> and must be not dereferenced). The pattern creation is as follows:</p>
          <pre><code class="language-cpp">
Sink_F sink_func;
// creation of the Sink pattern
Sink sink = Sink_Builder(sink_func).withParallelism(1)
                                   .withName("sink")
                                   .build();
          </code></pre>
          <p class="lead">The source is created with one replica.</p>
          <h2>Creating and running the application</h2>
          <p class="lead">Once the patterns (operators) have been created, they must be connected together. To do that, <code>WindFlow</code> provides a <code>MultiPipe</code> construct. In the basic case, it is essentially a sequence of multiple linear pipelines with streams crossing them. <code>MultiPipe</code> instances cannot be directly created by the user, but instead they are obtained from the <code>PipeGraph</code> construct which represents a sort of streaming environment where to build the WindFlow application. The following code shows how the application can be created using this construct:</p>
          <pre><code class="language-cpp">
PipeGraph env("vwap_app");
MultiPipe &pipe = env.add_source(source);
pipe.add(filter);
pipe.add(win_agg);
pipe.add(sink);
env.run(); // &lt;- run the app
          </code></pre>
          <p class="lead">The <code>PipeGraph</code> environment is created with a string provided to its constructor as the name of the application (useful for logging purposes, enabled with the compilation macro <code>LOG=pathname_dir</code> enabled). The value of the macro is the pathname of the directory where the log files will be written. The application has the following structure:</p>
          <p style="text-align:center;"><img src="imgs/multipipe_1.jpg" width="70%" align="middle"/></p>
          <p class="lead">According to the <code>FastFlow</code> programming model, each replica is implemented by a dedicated thread in the run-time system pinned on a specific core (actually a thread context) of the architecture. The automatic pinning can be disabled by compiling with the <code>FF_NO_DEFAULT_MAPPING</code> macro. In the figure, eight threads are used by the application. To reduce the amount of threads, <code>WindFlow</code> provides a <code>chaining</code> support to fuse operators' replicas into single threads (not always possible). In the example, we can apply chaining between the source operator and the filter one (same number of replicas). The benefit is not only in the thread reduction, but also because the data exchange among operators mapped onto the same thread is more efficient (it is based on function calls instead of using the lock-free <code>FastFlow</code> queues). The code change is very minimal:</p>
          <pre><code class="language-cpp">
...
pipe.chain(filter);
...
          </code></pre>
          <p class="lead">The corresponding application structure has now six threads as in the figure:</p>
          <p style="text-align:center;"><img src="imgs/multipipe_2.jpg" width="70%" align="middle"/></p>
          <p class="lead">This example, although useful to understand the philosophy of the library, does not cover all the provided features. Notably, the library supports the <code>merge</code> and the <code>split</code> of <code>MultiPipe</code> instances to create application graphs with a more general structure, useful to model more complex applications. Further details can be easily understood by reading the <code>doxygen</code> documentation alongside the source code available in <code>GitHub</code>.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; WindFlow (LGPL-3.0)</p>
    </div>
    <!-- /.container -->
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>

</body>

</html>
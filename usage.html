<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="WindFlow Home Page">
  <meta name="author" content="Gabriele Mencagli">
  <title>WindFlow</title>
  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="css/scrolling-nav.css" rel="stylesheet">
  <link href="css/prism.css" rel="stylesheet" />
</head>

<body id="page-top">
  <script src="js/prism.js"></script>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">WindFlow</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html">Overview</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="operators.html">Operators</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#Usage">Usage</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="performance.html">Performance</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="https://github.com/ParaGroup/WindFlow.git">Download</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="credits.html">Credits</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <header class="bg-primary text-white">
    <div class="container text-center">
      <!--<h1>WindFlow</h1>-->
      <img src="logo/logo_white.png" alt="WindFlow" height="180">
      <p class="lead">A C++17 Data Stream Processing Parallel Library for Multicores and GPUs</p>
    </div>
  </header>

  <section id="Usage">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h1>Use of the API</h1>
          <p class="lead">In this part, we show a simple application in order to describe how to use of the <code>WindFlow</code>'s API. For further details about the library, developers can refers to the <code>doxygen</code> documentation available in the source code.</p>
          <p class="lead">The application that we propose here is a simple financial application reading data ticks from a financial market. Logically, the application can be modeled as a pipeline of four stages connected with each other as in the figure below:</p>
          <p style="text-align:center;"><img src="imgs/application.jpg" width="100%" align="middle"/></p>
          <p class="lead">The source produces a stream of records with a stock symbol (string), volume (integer), price (float), timestamp (long), identifier (long) attributes. The stream is received by a filter operator in charge of dropping all the inputs except the ones with symbol equal to <code>"FOO-COMPANY"</code>. The third operator computes the Volume Weighted Average Price (VWAP) of the last <code>1,000</code> records by producing a new result every <code>10</code> new items. Results are received by the sink operator.</p>
          <h2>Creating Operators</h2>
          <p class="lead">First, we introduce the data type of the records exchanged by the operators. We develop the following class named <code>tick_t</code>:</p>
          <pre><code class="language-cpp">
// includes
#include&lt;windflow.hpp&gt;
...
// financial tick
struct tick_t
{
  std::string symbol;
  uint64_t id;
  uint64_t ts;
  float price;
  size_t volume;

  // default constructor
  tick_t(): key("undefined"), id(0), ts(0), price(0.0), volume(0) {}

  std::tuple<std::string, uint64_t, uint64_t> getControlFields() const
  {
    return std::make_tuple(key, id, ts);
  }

  void setControlFields(std::string _key, uint64_t _id, uint64_t _ts)
  {
    key = _key;
    id = _id;
    ts = _ts;
  }
};
          </code></pre>
          <p class="lead">All the data types exchanged by operators in <code>WindFlow</code> must be copy constructible, with a copy assignment operator and a default constructor. Furthermore, they <b><i>must</i></b> provide two public methods:</p>
          <ul>
            <li><b>getControlFields()</b>: the method returns a <code>std::tuple</code> with three parameters. The first is the key attribute (with <code>string</code> type in the example). The library supports as key attributes any C++ type <code>T</code> for which the <code>std::hash&lt;T&gt;()</code> function is defined. The second field is the unique identifier (of type <code>uint64_t</code> starting from zero) of the item within the substream. The last field of the tuple is the timestamp (starting from zero with granularity at the microsecond) represented by a <code>uint64_t</code> value;</li>
            <li><b>setControlFields()</b>: a method that allows the key attribute, the unique identifier and the timestamp to be set for the given input item.</li>
          </ul>
          <p class="lead"><b><u>Important Note</u></b>: the timestamp must be set in the Sources and it must be monotonically increasing in each replica of the Sources. The unique identifier must be included but it is generally not needed by the user explicitly (it is used by the run-time system for count-based windowed operators). As a rule of thumb and a good programming practice in the library, each replica of the operators producing new output values should count the number of outputs produced and the identifier should be set to this value before emitting each value (although this is not strictly mandatory).</p>
          <p class="lead">The first step is to create the source operator. The business logic in charge of generating the ticks is provided by the user to the operator builder through either a <b>lambda</b> expression, a plain <b>function</b>, or a <b>functor</b> object. In the code below, we define a functor class:</p>
          <pre><code class="language-cpp">
// source functor class
class Source_F {
public:
  uint64_t len; // stream length
  uint64_t sent;
  volatile unsigned long start_time;

  // constructor
  Source_F(uint64_t _len): len(_len), sent(0)
  {
    start_time = current_time_usecs(); // provided in the header of the library
  }

  // generation item-by-item
  bool operator()(tick_t &t)
  {
    t = readTuple(sent); // fill the symbol, price and volume fields (e.g., by reading the sent-th row of a file)
    t.id = sent++;
    t.ts = current_time_usecs() - start_time;
    if (sent < len)
      return true; // operator() will be called again on a new tick_t to be filled
    else
      return false; // this tick_t is the last one of the stream
  }
  ...
};
          </code></pre>
          <p class="lead">In the code, we have omitted the definition of the <code>readTuple()</code> function in charge of parsing input items from a network socket. In the example, the source generates a predefined number of items. To create the source operator, the developer should use the builder class provided by the library. So doing, using the last C++17 features (<b>Class Template Argument Deduction</b>), all the template arguments needed to instantiate the operator are automatically deduced by the function/functor/lambda provided to the builder constructor, thus making the life easier to the programmer in addition to provide a <code>fluent interface</code> for the operator creation. The construction of the source is shown below:</p>
          <pre><code class="language-cpp">
// main
int main(int argc, char *argv[]) {
    ...
    Source_F source_func(1000000);
    // creation of the Source operator
    Source source = Source_Builder(source_func).withName("mysource")
                                               .withParallelism(2)
                                               .build();
}
          </code></pre>
          <p class="lead">The source is created with two replicas and with a string corresponding to its name in the application.</p>
          <p class="lead">In case of support for <code>C++14</code> only, the source code must be modified by expliciting providing the template arguments to the operator builder, since they cannot be automatically deduced. The source code becomes:</p>
          <pre><code class="language-cpp">
// main
int main(int argc, char *argv[]) {
    ...
    Source_F source_func(1000000);
    // creation of the Source operator
    auto *source = Source_Builder&lt;decltype(source_func)&gt;(source_func).withName("mysource")
                                               .withParallelism(2)
                                               .build_ptr();
}
          </code></pre>
          <p class="lead">The filter operator is created in an analogous manner. First, a functor class is defined with the operator business logic, as shown below:</p>
          <pre><code class="language-cpp">
// filter functor
class Filter_F
{
public:
    bool operator()(tick_t &t)
    {
        if (t.symbol == "FOO-COMPANY")
            return true;
        else
            return false;
    }
};
          </code></pre>
          <p class="lead">All the input ticks with symbol not equal to <code>"FOO-COMPANY"</code> are dropped (return value is <code>false</code>). The operator is created by leveraging its builder class and, in this example, with the same parallelism of the source (we assume <code>C++17</code> in the rest of this example):</p>
          <pre><code class="language-cpp">
Filter_F filter_func;
// creation of the Filter operator
Filter filter = Filter_Builder(filter_func).withParallelism(2)
                                           .withName("myfilter")
                                           .build();
          </code></pre>
          <p class="lead">To compute the window aggregate, we use the <b>Win_Farm</b> operator. We note that in this application, all the items coming out from the filtering phase have the same symbol attribute. So, key-based parallelism is totally useless in this example. To instantiate the operator, we define its business logic. We use a function to do that (lambda expressions or functor objects are still allowed here):</p>
          <pre><code class="language-cpp">
// user-defined window function
void vwap(uint_64_t wid, const Iterable&lt;tick_t&gt; &win, result_t &r) {
    size_t total_volume = 0;
    float sum = 0;
    for (auto t: win) {
        sum += (t.price * t.volume);
        total_volume += t.volume;
    }
    result.vwap = sum/total_volume;
};
          </code></pre>
          <p class="lead">In this example, the function uses the non-incremental signature that computes the window when it is ready to be processed by giving the read-only access to all of its items through a <code>Iterable</code> object. Other definitions of the function (e.g., incremental) are allowed (see the <code>doxygen</code> documentation). The type <code>result_t</code> is the result data type computed per window, providing the same control methods of <code>tick_t</code> (i.e. <code>getControlFields()</code> and <code>setControlFields()</code>). For window-based operators, the run-time system automatically sets the key attribute, unique identifier of the window and the timestamp of the window result automatically. The operator is created through its builder class:</p>
          <pre><code class="language-cpp">
Win_Farm win_agg = WinFarm_Builder(vwap).withCBWindow(1000, 10)
                                        .withParallelism(3)
                                        .withName("myvwap")
                                        .build();
          </code></pre>
          <p class="lead">The operator is created with three replicas and with a count-based window semantics. Finally, the sink operator is created, first implementing its business logic:</p>
          <pre><code class="language-cpp">
// sink functor
class Sink_F
{
    size_t received;
public:
    // constructor
    Sink_Functor(): received(0) {}

    // operator()
    void operator()(std::optional&lt;result_t&gt; &out)
    {
        if (out) {
            received++;
            cout << "Window " << *out.id << " vwap " << *out.vwap << endl;
        }
        else
            cout << "End stream" << endl;
    }
};
          </code></pre>
          <p class="lead">The function is called by the run-time system of the library each time a new item is received. The item is encapsulated in a <code>std::optional</code>. This allows checking the end of the stream (in that case the optional returns <code>false</code> and must be not dereferenced). The operator creation is as follows:</p>
          <pre><code class="language-cpp">
Sink_F sink_func;
// creation of the Sink operator
Sink sink = Sink_Builder(sink_func).withParallelism(1)
                                   .withName("sink")
                                   .build();
          </code></pre>
          <p class="lead">The source is created with one replica.</p>
          <h2>Creating and Running the Application</h2>
          <p class="lead">Once the operators have been created, they must be connected together. To do that, <code>WindFlow</code> provides a <code>MultiPipe</code> construct. In the basic case, it is essentially a sequence of multiple linear pipelines with streams crossing them. <code>MultiPipe</code> instances cannot be directly created by the user, but instead they are obtained from the <code>PipeGraph</code> construct which represents a sort of streaming environment where to build the WindFlow application. The following code shows how the application can be created using this construct:</p>
          <pre><code class="language-cpp">
PipeGraph env("vwap_app", Mode::DETERMINISTIC);
MultiPipe &pipe = env.add_source(source);
pipe.add(filter);
pipe.add(win_agg);
pipe.add_sink(sink);
env.run(); // &lt;- run the app
          </code></pre>
          <p class="lead">The <code>PipeGraph</code> environment is created with a string provided to its constructor as the name of the application (useful for logging purposes, enabled with the compilation macro <code>TRACE_WINDFLOW</code> enabled). The second parameter of the <code>PipeGraph</code> is the <b> execution mode</b>. Two modes are supported:</p>
          <ul>
            <li><b>DEFAULT</b>: this mode does not provide any guarantee of the ordering of inputs received by any replica of an operator in the application. It can be used if ordering is not really a matter for the application. Actually, this is the only available execution mode if sources cannot generate in-order timestamps (e.g., because they already receive disordered data from external data producers);</li>
            <li><b>DETERMINISTIC</b>: this modes guarantees that every replica of each operator in the application always receives inputs ordered by timestamp. The general precondition to correctly use this execution mode is that all sources of the applications are able to generate the input streams with in-order timestamps.</li>
          </ul>
          <p class="lead">The application has the following structure:</p>
          <p style="text-align:center;"><img src="imgs/multipipe_1.jpg" width="90%" align="middle"/></p>
          <p class="lead">The <i>logical view</i> (using the Flink's jargon) shows how operators are connected together. It is possible to generate a DOT representation of the logical view of a <code>PipeGraph</code> by invoking the <tt>dump_DOTGraph()</tt> method (the code needs to be compiled with the <code>GRAPHVIZ_WINDFLOW</code> macro, and properly linked to the <tt>cgraph</tt> and <tt>gvc</tt> libraries.)</p>
          <p class="lead">According to the <code>FastFlow</code> programming model, each replica is implemented by a dedicated thread in the run-time system pinned on a specific core (actually a thread context) of the architecture. The automatic pinning can be disabled by compiling with the <code>FF_NO_DEFAULT_MAPPING</code> macro. In the figure, eight threads are used by the application. To reduce the amount of threads, <code>WindFlow</code> provides a <code>chaining</code> support to fuse operators' replicas into single threads (not always possible). In the example, we can apply chaining between the source operator and the filter one (same number of replicas without keyby distribution in the middle). The benefit is not only in the thread reduction, but also because the data exchange among operators mapped onto the same thread is more efficient (it is based on function calls instead of using the lock-free <code>FastFlow</code> queues). The code change is very minimal:</p>
          <pre><code class="language-cpp">
...
pipe.chain(filter);
...
          </code></pre>
          <p class="lead">The corresponding application structure has now six threads as in the figure:</p>
          <p style="text-align:center;"><img src="imgs/multipipe_2.jpg" width="90%" align="middle"/></p>
          <p class="lead">This example, although useful to understand the philosophy of the library, does not cover all the provided features. Notably, the library supports the <code>merge</code> and the <code>split</code> of <code>MultiPipe</code> instances to create application graphs with more general structures, useful to model more complex applications. Further details can be easily understood by reading the <code>doxygen</code> documentation alongside the source code available in <code>GitHub</code> with the provided examples in the <tt>windflow/tests</tt> folder.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; WindFlow (LGPL-3.0)</p>
    </div>
    <!-- /.container -->
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>

</body>

</html>
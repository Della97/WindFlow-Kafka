<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="WindFlow Home Page">
  <meta name="author" content="Gabriele Mencagli">
  <title>WindFlow</title>
  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="css/scrolling-nav.css" rel="stylesheet">
  <link href="css/prism.css" rel="stylesheet" />
</head>

<body id="page-top">
  <script src="js/prism.js"></script>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">WindFlow</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html">Overview</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#Patterns">Patterns</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="usage.html">Usage</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="performance.html">Performance</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="https://github.com/ParaGroup/WindFlow.git">Download</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="credits.html">Credits</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <header class="bg-primary text-white">
    <div class="container text-center">
      <!--<h1>WindFlow</h1>-->
      <img src="logo/logo_white.png" alt="WindFlow" height="180">
      <p class="lead">A C++17 Data Stream Processing Parallel Library for Multicores and GPUs</p>
    </div>
  </header>

  <section id="Patterns">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h1>Patterns (Operators)</h1>
          <p class="lead"><code>WindFlow</code> provides a quite rich set of common operators, as done in traditional streaming frameworks. The figure below shows the list of operators and a brief description for each of them.</p>
          <p style="text-align:center;"><img src="imgs/operators.jpg" width="80%" align="middle"/></p>
          <h2>Parallelism</h2>
          <p class="lead"> While sources, basic operators and sinks have an immediately clear semantics for programmers a bit expert in open-source stream processing frameworks, windowed operators in <code>WindFlow</code> provide a unique set of programming abstractions [1] to express different kinds of parallelism addressing window-based streaming analytics tasks:</p>
          <ul>
            <li><b>Key-based parallelism</b>: it is the default parallelism exploitation pattern in stream processing systems dealing with stateful computations. The assumption is that the stream conveys input items belonging to multiple logical substreams composed of items having the same value of a <i>key attribute</i> (a.k.a. <b>keyed streams</b>). The idea is to execute in parallel the processing of sliding windows belonging to different substreams. The pattern enabling this behavior is the <b>Keyed Farm</b> (KF) one</li>
            <li><b>Inter-Window parallelism</b>: in case of high-speed streams and computationally demanding tasks, sliding windows can become ready to be computed very fastly. The idea is to split the set of windows to compute among different parallel entities in charge of doing the processing in parallel on distinct windows (regardless the fact that they belong to different or to the same substream). The patterns enabling this behavior are the <b>Windowed Farm</b> (WF) and the <b> Paned Farm</b> (PF) ones</li>
            <li><b>Intra-Window parallelism</b>: the idea is to go in parallel within the computation of each window, by splitting its content in partitions that are processed in parallel while the results of the partitions are computed and merged to obtain window-wise results. The patterns enabling this behavior are the <b>Paned Farm</b> (PF) and the <b>Windowed Map-Reduce</b> (WMR) ones</li>
          </ul>
          <p class="lead">The idea of these parallelism dimensions is sketched in the figure below. For simplicity, we show an example with <code>count-based windows</code> of length of <code>6</code> items sliding every <code>2</code> items. However, the library also provides support to <code>time-based windows</code> (with event time semantics) instantiated with both <code>non-incremental</code> and <code>incremental</code> queries.</p>
          <p style="text-align:center;"><img src="imgs/windows.jpg" width="100%" align="middle"/></p>
          <p class="lead">Intra-window parallelism needs additional explanations. The library supports patterns/operators enabling the parallel processing within each window. The first is based on the well-known <code>paned approach</code> [2], where each window is split into tumbling windows called <i>panes</i> with length equal to the GDC between the window length and its slide (in the example, each pane is two items long). The operator computes a partial result per pane (by processing them in parallel if possible), and the panes are aggregated together to produce window results (in the example three pane results are needed per window). A good point of this approach is that pane results shared by consecutive windows do not need to be recomputed by improving the computation performance.</p>
          <p class="lead">The second approach to intra-window parallelism is based on the <code>map-reduce</code> idea: each window is split into partitions, and a partial result is computed per partition. Then, partition results are aggregated into window-wise results. Although similar to the paned approach, here the size of the partitions depends on the number of parallel replicas involved in the processing of the operator (two in the figure below, right-hand side), leading to the possibility to decrease the processing latency proportionally to the replication degree used the pattern. However, differently from the paned approach, windows are recomputed from scratch although in parallel.</p>
          <p style="text-align:center;"><img src="imgs/windows-2.jpg" width="100%" align="middle"/></p>
          <p class="lead">We point out that the existing frameworks fail to provide all these parallelism dimensions in an integrated and easy to use manner. As an example, Apache Storm and Apache Flink provide natively key-based parallelism, while intra-window parallelism is naturally provided in Spark Streaming as a derivation from the Spark engine for batch processing and map-reduce computations.</p>
          <h2>GPU support</h2>
          <p class="lead">Window-based patterns have also a GPU implementation in the library (the approach has been described in [3]). The idea is to batch a set of input items corresponding to the data needed to process <i>B>0</i> consecutive windows of the same substream, where <i>B</i> is a configurable parameter chosen by the user. The library, using <code>CUDA</code> (v10), offloads the processing of each batch on the device where all the windows within a batch are processed in parallel by distinct <code>CUDA</code> threads. This idea is depicted in the figure below.</p>
          <p style="text-align:center;"><img src="imgs/windows-gpu.jpg" width="100%" align="middle"/></p>
          <p class="lead">This approach is applied to all the windowed operators in the library providing a GPU variant for each of them. While in the Keyed Farm and Windowed Farm pattern each <code>CUDA</code> thread is in charge of processing an entire window within a batch, in the Paned Farm and Windowed Map-Reduce patterns the programmer can choose which of the two phases of the computation are going to be offloaded on the GPU:</p>
          <ul>
            <li>in the Paned Farm pattern, either the <b>PLQ</b> stage (Pane-level Sub-Query), producing a result per pane, or the <b>WLQ</b> (Window-level Sub-Query) aggregating pane results into window results can be offloaded on the device while the others is run (in parallel) on the CPU cores</li>
            <li> in the Windowed Map-Reduce pattern, either the <b>MAP</b> stage (processing partitions) or the <b>REDUCE</b> phase (merging partitions results) can be executed on the device while the others is run on the CPU cores</li>
          </ul>
          <h2>References</h2>
          <ol>
            <li>Tiziano Matteis and Gabriele Mencagli. 2017. Parallel Patterns for Window-Based Stateful Operators on Data Streams: An Algorithmic Skeleton Approach. Int. J. Parallel Program. 45, 2 (April 2017), 382-401. DOI: https://doi.org/10.1007/s10766-016-0413-x</li>
            <li>Jin Li, David Maier, Kristin Tufte, Vassilis Papadimos, and Peter A. Tucker. 2005. No pane, no gain: efficient evaluation of sliding-window aggregates over data streams. SIGMOD Rec. 34, 1 (March 2005), 39-44. DOI=http://dx.doi.org/10.1145/1058150.1058158</li>
            <li>T. De Matteis, G. Mencagli, D. De Sensi, M. Torquati and M. Danelutto. GASSER: An Auto-Tunable System for General Sliding-Window Streaming Operators on GPUs. IEEE Access, vol. 7, pp. 48753-48769, 2019.</li>
          </ol>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; WindFlow (LGPL-3.0)</p>
    </div>
    <!-- /.container -->
  </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>
  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>
</body>

</html>